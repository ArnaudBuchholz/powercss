
topSmap = {
  _vsheet_map_
    |- `vsheet_id1`
    |  |- _vsheet_id_     : `vsheet_id1`
    |  |- _selector_list_ : `selector_list`
    |  |- _selector_ms_   : `timestamp`
    |  |- _mixin_map_     : `mixin_map`
    |  +- _mixin_ms_      : `timestamp`
    |
    +- `vsheet_id2`
       |- _vsheet_id_     : `vsheet_id2`
       |- _selector_list_ : `selector_list`
       |- _selector_ms_   : `timestamp`
       |- _mixin_map_     : `mixin_map`
       +- _mixin_ms_      : `timestamp`

  _cascade_map_
    |- `cascade_id1`
    |  |- _cascade_id_         : `cascade_id1`
    |  |- _vsheet_list_        : `vsheet_list`
    |  |- _vsheet_ms_          : `timestamp`
    |  |- _mixin_map_          : {...}
    |  |- _mixin_ms_           : `timestamp`
    |  |- _merged_vsheet_list_ : `merged_vsheet_list`
    |  |- _merged_mixin_map_   : `merged_mixin_map`
    |  |- _merged_vsheet_ms_   : `timestamp`
    |  |- _css_str_            : `cascade_css`
    |  +- _css_ms_             : `timestamp`
    |
    +- `cascade_id2`
       |- _cascade_id_         : `cascade_id2`
       |- _vsheet_list_        : `vsheet_list`
       |- _vsheet_ms_          : `timestamp`
       |- _mixin_map_          : {...}
       |- _mixin_ms_           : `timestamp`
       |- _merged_vsheet_list_ : `merged_vsheet_list`
       |- _merged_mixin_map_   : `merged_mixin_map`
       |- _merged_vsheet_ms_   : `timestamp`
       |- _css_str_            : `cascade_css`
       +- _css_ms_             : `timestamp`

topCmap._regen_type_list_ = [ '_none_', '_merge_', '_prepare_', '_all_' ];

regen_cascade( cascade_obj, regen_type ) {
  if ( topCmap._regen_type_list_.indexOf( regen_type ) === -1 ) {
    lotIt( '_regen_type_not_supported_', regen_type );
    return;
  }
  if ( regen_type === '_none_' ) { return regen_type; }
  if ( cascade_obj._merged_vsheet_ms_ < cascade_obj._vsheet_ms_
    || cascade_obj._merged_vsheet_ms_ < cascade_obj._mixin_ms_
    || cascade_obj._merged_vsheet_ms_ < topSmap._global_mixin_ms_
  ) {
    result_map = mergeCascadeList( vsheet_list );
    cascade_obj._merged_vsheet_list_ = result_map._merged_vsheet_list_
    cascade_obj._merged_mixin_map_   = result_map._merged_mixin_map_
    cascade_obj._merged_vsheet_ms_   = NOW
  }
  if ( regen_type === '_merge_' ) { return regen_type; }
  if ( cascade_obj._css_ms_ < cascade_obj._merged_vsheet_ms_ ) {
    cascade_obj._css_str_ = makeCssStr(
      cascade_obj._merged_vsheet_list_,
      cascade_obj._merged_mixin_map_
    );
  }
  if ( regen_type === '_prepare_' ) { return regen_type; }

  if ( topSmap._style_el_idx_
    === topSmap._active_cascade_list_.indexOf( cascade_obj._cascade_id )
  ) {
    style_el = topSmap._style_el_list_[ topSmap._style_el_idx_ ];
    writeToStyleEl ( style_el, cascade_obj._css_str_ );
  }
  return regen_type;
}

General methods
- `_initModule_`
- `_getBufferJson_`       // e.g. [ cascade\_idX, cascade\_idY ]
- `_setGlobalMixinMap_`   // mode: add, change, delete

Vsheet methods
- `_getVsheetJson_` // get selector\_list or mixin\_map
                    //   selector\_list\_ms, mixin\_map\_ms
- `_setVsheet_`     // mode  : add, change, delete
                    // assets: selector\_list and/or mixin\_map

Cascade methods
- `_getCascadeJson_` // get cascade\_obj or mixin\_map
                     //     selector\_list\_ms, mixin\_map\_ms
- `_setCascade_`     // mode: add, change, delete
                     // assets: vsheet\_list, mixin\_map
                     // Also use for prepareCascade
- `_useCascade_`
- `_disablePcss_`    // Disables both stylesheets

# _vsheet_map_ use cases
## Add vsheet
  - Function call
    _setVsheet_({
      _vsheet_id_     : '_base_',
      _mode_str_      : '_add_',
      _selector_list_ : [...],
      _mixin_map_     : {...},
      _regen_type_    : '_merge_' // '_all_|_prepare_|_merge_|_none_'
    });

  - Get existing vsheet record from topSmap._vsheet_map_.`vsheet_id`
  - If found log warning and return undef
  topSmap._sheet_map_.`vsheet_id` = {
    _selector_list_ : [],
    selector_
  };
  - If provided
      topSmap._vsheet_map_.`vsheet_id`._selector_list_ = selector_list
      topSmap._vsheet_map_.`vsheet_id`._selector_ms_     = NOW
  - If provided
      vsheet_map.`vsheet_id`._mixin_map_ = mixin_map
      vsheet_map.`vsheet_id`._mixin_ms_  = NOW
  - An added vsheet list cannot affect cascades, so regen_type is ignored 

## Change vsheet (selector_list or mixin_map)
  - Function call
    _setVsheet_({
      _vsheet_id_     : '_base_',
      _mode_str_      : '_change_',
      _selector_list_ : [...],
      _mixin_map_     : {...}
      _regen_type_     : '_merge_' // '_all_|_prepare_|_merge_|_none_'
    });

  - Get existing vsheet record from vsheet_map
  - If not found log warning and return undef
  - If provided
      topSmap._vsheet_map_.`vsheet_id`._selector_list_ = selector_list
      topSmap._vsheet_map_.`vsheet_id`._selector_ms_     = NOW
      do_vsheet_regen = true;
  - If provided
      vsheet_map.`vsheet_id`._mixin_map_ = mixin_map
      vsheet_map.`vsheet_id`._mixin_ms_  = NOW
      do_vsheet_regen = true;
  - if ( ! do_vsheet_regen ) { return; }

  - Consider each cascade_obj in _cascade_map_
    - If vsheet_list contains vsheet_id
      - Set cascade_obj._selector_ms_ to NOW
  - End loop
  - regen_cascade( cascade_obj, regen_type )
  - return vsheet_id

## Delete only vsheet selector list
   Deleting a selector list independently is not supported.
   However, one may change the _selector_list_ to an empty array
   for a similar effect.

## Delete only vsheet mixin map
   Deleting a vsheet mixin map independently is not supported.
   However, one may change the _mixin_map_ to an empty object
   for a similar effect.

## Delete a vsheet
  - Function call
    _setVsheet_({
      _vsheet_id_  : '_base_',
      _mode_str_   : '_delete_',
      _regen_type_ : '_merge_' // '_all_|_prepare_|_merge_| _none_'
    });

  - Get existing vsheet record from vsheet_map
  - If not found log warning and return undef
  - Delete topSmap._vsheet_map_.`vsheet_id`
      do_vsheet_regen = true;
  - if ( ! do_vsheet_regen ) { return; }

  - Consider each cascade_obj in _cascade_map_
    - If vsheet_list contains `vsheet_id`
      - Remove `vsheet_id` from vsheet_list
      - Set cascade_obj._vsheet_ms_ to NOW
  - End
  - regen_cascade( cascade_obj, regen_type )
  - return `vsheet_id`

## Get vsheet snapshot
  - function call
    _getVsheetJson_({
      _vsheet_id_  : '_base_'
    });

  - Get existing vsheet record from vsheet_map
  - If not found log warning and return undef
  - JSON.stringify record

# _cascade_map_ use cases
## Add cascade
  - Function call
    _setCascade_({
      _cascade_id_    : '_example001_',
      _mode_str_      : '_add_',
      _vsheet_list_   : [ '_base_', '_box_' ],
      _mixin_map_     : {...},
      _regen_type_    : '_merge_' // '_all_|_prepare_|_merge_|_none_'
    });

  - Get existing cascade_obj from topSmap._cascade_map_.`cascade_id`
  - If found log warning and return undef
  - Ensure every provided key in the vsheet_list is defined in
    topSmap._vsheet_map.  If not, log warning and return undef

  - If provided
      topSmap._cascade_map_.`cascade_id`._vsheet_list_ = vsheet_list
      topSmap._cascade_map_.`cascade_id`._vsheet_ms_   = NOW
  - If provided
      cascade_map.`cascade_id`._mixin_map_ = mixin_map
      cascade_map.`cascade_id`._mixin_ms_  = NOW
  - An added cascade list cannot be effect cascades, so regen_type is ignored 

## Change cascade (vsheet_list or mixin_map)
  - Function call
    _setCascade_({
      _cascade_id_   : '_example001_',
      _mode_str_     : '_change_',
      _vsheet_list_  : [...],
      _mixin_map_    : {...}
      _regen_type_   : '_merge_' // '_all_|_prepare_|_merge_|_none_'
    });

  - Get existing cascade_obj from topSmap._cascade_map_.`cascade_id`
  - If not found log warning and return undef
  - If provided
      topSmap._cascade_map_.`cascade_id`._vsheet_list_ = vsheet_list
      topSmap._cascade_map_.`cascade_id`._vsheet_ms_   = NOW
      do_cascade_regen = true;
  - If provided
      topSmap._cascade_map_.`cascade_id`._mixin_map_ = mixin_map
      topSmap._cascade_map_.`cascade_id`._mixin_ms_  = NOW
      do_cascade_regen = true;
  - if ( ! do_cascade_regen ) { return; }
  - regen_cascade( cascade_obj, regen_type )
  - return vsheet_id

## Delete only cascade vsheet_list
   Deleting a cascade list independently is not supported.
   However, one may change the _selector_list_ to an empty array
   for a similar effect.

## Delete only cascade mixin map
   Deleting a cascade mixin map independently is not supported.
   However, one may change the _mixin_map_ to an empty object
   for a similar effect.

## Delete a cascade
  - Function call
    _setCascade_({
      _cascade_id_ : '_example001_',
      _mode_str_   : '_delete_'
    });

  - Get existing cascade_obj from topSmap._cascade_map_.`cascade_id`
  - If not found log warning and return undef
  - Delete topSmap._cascade_map_.`cascade_id`
  - If this is the active cascade, disable the stylesheet
  - return `cascade_id`

## Use a cascade
## Disable pcss

## Get cascade snapshot
  - function call
    _getCascadeJson_({
      _cascade_id_  : '_base_'
    });

  - Get existing cascade record from cascade_map
  - If not found log warning and return undef
  - JSON.stringify record

# _global_ use cases
## Change mixin_map

